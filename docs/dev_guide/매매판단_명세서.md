# 매매판단 프롬프트 명세서

> **📅 최초 작성**: 2025-10-24
> **📅 최종 업데이트**: 2025-10-25
> **📦 버전**: v1.6
> **🔗 실제 프롬프트 위치**:
> - `ai_strategy/prompts/cio_defensive.txt` (Fear & Greed < 45)
> - `ai_strategy/prompts/cio_neutral.txt` (45 ≤ F&G ≤ 55)
> - `ai_strategy/prompts/cio_aggressive.txt` (F&G > 55)
> - `ai_strategy/prompts/cio_base_rules.txt` (공통 규칙)
> - `ai_strategy/prompts.py` (페르소나 선택 로직)
> - `ai_strategy/process2.py` (Process2 메인 로직)

---

## 0. 중요: 페르소나 시스템 이해

### 0.1 프롬프트 로그 vs 실제 코드 차이 ⚠️

**매우 중요한 개념**: Process2 프롬프트 로그를 분석할 때 흔히 하는 착각

```
프롬프트 로그 (예: 매매판단_20251024_222420.txt)
├── 시각: 2025-10-24 22:24:20
├── 시장 상황: Fear & Greed 30 (Fear)
├── 표시된 페르소나: Risk Guardian (방어적)
└── 의미: **현재 시장에 맞는 페르소나가 선택된 것**
    ❌ 착각: "Process2는 Risk Guardian만 사용한다"
    ✅ 사실: "이 순간의 시장은 Fear이므로 Risk Guardian이 선택됨"

실제 코드 (prompts.py, process2.py)
├── 페르소나 파일 3개 존재:
│   ├── cio_defensive.txt (Risk Guardian)
│   ├── cio_neutral.txt (Balanced Analyst)
│   └── cio_aggressive.txt (Alpha Predator)
├── market_phase 기반 동적 선택:
│   └── cache.py의 점수 계산 (F&G + BTC/ETH 지표)
└── 의미: **시장 상황에 따라 3가지 페르소나 중 하나 선택**
```

**핵심 교훈**:
- **프롬프트 로그 = 특정 시점의 스냅샷** (현재 선택된 페르소나만 표시)
- **실제 코드 = 전체 시스템 구조** (3가지 페르소나 동적 전환)
- **분석 시 주의**: 로그만 보고 판단하지 말고 코드 구조 확인 필수

### 0.2 CIO와 Process2의 프롬프트 공유 구조

**Process2는 CIO와 동일한 프롬프트 파일을 100% 공유합니다**:

```
ai_strategy/prompts/
├── cio_aggressive.txt    → CIO & Process2 공통 사용
├── cio_defensive.txt     → CIO & Process2 공통 사용
├── cio_neutral.txt       → CIO & Process2 공통 사용
└── cio_base_rules.txt    → CIO & Process2 공통 사용

ai_strategy/prompts.py:
CIO_AGGRESSIVE = _load_prompt_from_file('cio_aggressive.txt')
CIO_DEFENSIVE = _load_prompt_from_file('cio_defensive.txt')
CIO_NEUTRAL = _load_prompt_from_file('cio_neutral.txt')

# Process2가 사용하는 별칭 (하위 호환성)
AGGRESSIVE_CHARTER = CIO_AGGRESSIVE
DEFENSIVE_PRINCIPLES = CIO_DEFENSIVE
BALANCED_PRINCIPLES = CIO_NEUTRAL
```

**의미**:
- ✅ **CIO v1.3 개선사항이 Process2에 자동 반영**
- ✅ **두 시스템 간 일관성 보장**
- ✅ **유지보수 효율성 극대화** (프롬프트 1번만 수정하면 양쪽 모두 반영)

### 0.3 페르소나 선택 로직 (market_phase 기반)

CIO와 Process2 모두 **동일한 market_phase**를 사용하여 페르소나 선택:

```python
# data_manager/cache.py (Lines 470-569)
# Fear & Greed (30점) + BTC (35점) + ETH (20점) = 85점 만점

market_score = 0

# 1. Fear & Greed Index
if fear_greed >= 75: market_score += 30
elif fear_greed > 55: market_score += 15
elif fear_greed <= 25: market_score -= 30
elif fear_greed < 45: market_score -= 15

# 2. BTC 추세 (MA120 + RSI)
if btc_price > btc_ma_120: market_score += 25
if btc_rsi > 55: market_score += 10

# 3. ETH 추세 (MA120 + RSI)
if eth_price > eth_ma_120: market_score += 15
if eth_rsi > 55: market_score += 5

# 최종 market_phase 결정
if market_score >= 75: market_phase = "extreme_greed"
elif market_score >= 55: market_phase = "greed"
elif market_score > 45: market_phase = "neutral"
elif market_score > 25: market_phase = "fear"
else: market_phase = "extreme_fear"
```

```python
# ai_strategy/prompts.py (Lines 52-85)
def _get_system_prompt(provider: str, market_phase: str) -> str:
    if market_phase in ['greed', 'extreme_greed']:
        persona_prompt = AGGRESSIVE_CHARTER  # Alpha Predator
        logger.info("🧠 AI 페르소나: 공격적 투자자 (Alpha Predator)")
    elif market_phase in ['fear', 'extreme_fear']:
        persona_prompt = DEFENSIVE_PRINCIPLES  # Risk Guardian
        logger.info("🧠 AI 페르소나: 리스크 수호자 (Risk Guardian)")
    else:  # 'neutral'
        persona_prompt = BALANCED_PRINCIPLES  # Balanced Analyst
        logger.info("🧠 AI 페르소나: 균형 분석가 (Balanced Analyst)")

    return final_prompt
```

### 0.4 페르소나별 특성 (CIO v1.3 반영)

| 페르소나 | market_phase | 현금 비중 | 개별 상한 | 신규 편입 접근 |
|---------|-------------|----------|---------|--------------|
| **Risk Guardian** | fear, extreme_fear | 60-80% | 15% (메가캡 20%) | 질문 기반 검증 (보수적) |
| **Balanced Analyst** | neutral | 30-60% | 20% (메가캡 25%) | 동등 평가 (중립적) |
| **Alpha Predator** | greed, extreme_greed | 20-40% | 30% (모두) | 진입 기본 (적극적) |

**CIO v1.3 개선사항 자동 반영**:
- ✅ 질문 기반 신규 평가 (prescriptive 규칙 제거)
- ✅ 변동성 연동 현금 비중 조정 (3단계 시스템)
- ✅ 페르소나별 차별화된 할당 원칙
- ✅ 상관관계 관리 기준 (0.7+/0.8+/0.9+)

### 0.5 System Prompt vs User Prompt 구조

```
┌─────────────────────────────────────────┐
│           Process2 프롬프트              │
├─────────────────────────────────────────┤
│ [System Prompt] (페르소나 + 공통 규칙)   │
│  ├── 페르소나 파일 (market_phase 기반)   │
│  │   ├── cio_defensive.txt              │
│  │   ├── cio_neutral.txt                │
│  │   └── cio_aggressive.txt             │
│  └── 공통 규칙                           │
│      └── cio_base_rules.txt             │
├─────────────────────────────────────────┤
│ [User Prompt] (동적 데이터)              │
│  ├── 0. CIO의 최신 전략 브리핑 ⭐        │
│  ├── 1. 보유 현황                        │
│  ├── 2. 시장 데이터 (G섹터/C섹터)        │
│  ├── 3. Fear & Greed                    │
│  └── 4. 출력 템플릿 강제                 │
└─────────────────────────────────────────┘
```

**CIO와 Process2의 차이**:
- **CIO User Prompt**: VERIFIED 체크리스트 (AI 모드만)
- **Process2 User Prompt**: CIO 전략 브리핑 (최신 목표 비중)

---

## 1. 핵심 철학

### 1.1 Process2의 본질

**Process2는 CIO의 목표 비중을 "참고"하여 실제 매매 타이밍을 판단하는 트레이더입니다.**

```
┌─────────────────────────────────────────┐
│   Process2 = 실시간 트레이더             │
├─────────────────────────────────────────┤
│ 1. CIO 목표 비중 "참고" (강제 아님)      │
│    → 방향성 가이드                       │
│                                         │
│ 2. G섹터/C섹터 신호 종합                 │
│    → 실시간 매매 타이밍 포착             │
│                                         │
│ 3. 과매매 방지                           │
│    → 무분별한 매매 억제                  │
│                                         │
│ 4. 데이터 기반 자율 판단                 │
│    → 맥락 고려한 최종 결정               │
└─────────────────────────────────────────┘
```

### 1.2 CIO vs Process2 관계

**CIO와 Process2는 상하 관계가 아니라 협력 관계입니다.**

```
CIO (Chief Investment Officer)
- 역할: 포트폴리오 전체 관점에서 목표 비중 설정
- 주기: 4시간마다
- 특징: 전략적, 장기적 관점

   ↓ (목표 제시, 강제 아님)

Process2 (Real-time Trader)
- 역할: 실시간 신호 분석하여 매매 타이밍 판단
- 주기: 1시간마다
- 특징: 전술적, 단기적 관점
```

### 1.3 템플릿 기반 강제 출력 시스템

**Process2는 JSON 템플릿을 강제로 출력해야 합니다.**

```python
REQUIRED_TEMPLATE = {
    "decisions": [
        {
            "symbol": "BTC",
            "action": "buy" | "sell" | "hold",
            "percentage": 5.0,
            "reason": "구체적 근거",
            "urgency": "normal" | "high"
        }
    ],
    "rationale": "전체 판단 근거"
}
```

**템플릿 미준수 시 → 시스템 크래시**

---

## 2. 판단 원칙 (우선순위)

### 2.1 1순위: G섹터/C섹터 신호 종합

**Process2는 개별 코인의 G섹터/C섹터 신호를 종합 분석합니다.**

#### G섹터 (Growth Sector) - 공격 신호
```python
# BUY 신호
✅ MA120 위 (강한 상승 추세)
✅ MACD 일봉 상승 (중장기 모멘텀)
✅ MACD 1시간 상승 (단기 모멘텀)
✅ RSI 40~70 (적정 수준)
✅ Fear & Greed > 50 (시장 낙관)

# SELL 신호
❌ MA120 아래 (하락 추세)
❌ MACD 일봉 하락
❌ RSI > 80 (과열)
```

#### C섹터 (Conservative Sector) - 방어 신호
```python
# HOLD/보수적 BUY 신호
✅ MA60 위 (중기 지지)
✅ 거래량 안정적
✅ RSI 30~50 (저평가~중립)
✅ Fear & Greed 25~50 (공포~중립)

# SELL 신호
❌ MA60 아래 (중기 지지 이탈)
❌ 거래량 급감 (관심 저하)
❌ RSI < 30 (과매도, 추가 하락 우려)
```

### 2.2 2순위: CIO 목표 비중 참고

**CIO 목표 비중은 "참고 자료"이지 "강제 명령"이 아닙니다.**

```python
# CIO 목표 비중 활용 방법
if cio_target > current_weight:
    direction = "BUY 방향 검토"
    # 하지만 G섹터 신호가 부정적이면 HOLD 가능
elif cio_target < current_weight:
    direction = "SELL 방향 검토"
    # 하지만 단기 조정 후 반등 신호면 HOLD 가능
else:
    direction = "HOLD 방향 검토"
    # 하지만 긴급 신호 발생 시 BUY/SELL 가능
```

**CIO를 무시할 수 있는 경우**:
1. CIO 목표 증가 → 하지만 G섹터 신호 모두 부정적 → HOLD
2. CIO 목표 감소 → 하지만 단기 급락 후 반등 신호 → HOLD
3. CIO 목표 유지 → 하지만 긴급 매수/매도 신호 발생 → BUY/SELL

### 2.3 3순위: 과매매 방지

**무분별한 매매를 억제합니다.**

#### 과매수 방지
```python
# 1시간 내 동일 코인 반복 매수 제한
if recent_buy_count >= 2:
    action = "HOLD"
    reason = "과매수 방지 (1시간 내 2회 이상 매수)"
```

#### 과매도 방지
```python
# 1시간 내 동일 코인 반복 매도 제한
if recent_sell_count >= 2:
    action = "HOLD"
    reason = "과매도 방지 (1시간 내 2회 이상 매도)"
```

#### 미세 조정 방지
```python
# 비중 차이 1% 미만 시 HOLD
if abs(cio_target - current_weight) < 1.0:
    action = "HOLD"
    reason = "미세 조정 불필요 (비중 차이 1% 미만)"
```

### 2.4 4순위: 긴급도 판단

**긴급 상황에서는 즉시 대응합니다.**

#### HIGH 긴급도 조건
```python
# 즉시 매수 필요
✅ MA120 돌파 + MACD 골든크로스 + 거래량 급증
✅ 주요 저항선 돌파 + Fear & Greed 급등

# 즉시 매도 필요
❌ MA120 이탈 + MACD 데드크로스 + 거래량 급감
❌ 주요 지지선 이탈 + Fear & Greed 급락
```

#### NORMAL 긁급도
```python
# 일반적인 매수/매도
- G섹터 신호 긍정적 → 점진적 매수
- C섹터 신호 부정적 → 점진적 매도
```

### 2.5 판단 우선순위 요약

```
1순위: G섹터/C섹터 신호 종합
   ↓
2순위: CIO 목표 비중 참고 (강제 아님)
   ↓
3순위: 과매매 방지
   ↓
4순위: 긴급도 판단
   ↓
최종 결정: action (buy/sell/hold) + urgency (normal/high)
```

---

## 3. 특수 규칙

### 3.1 템플릿 강제 출력 규칙 ⭐

**Process2는 반드시 JSON 템플릿을 정확히 출력해야 합니다.**

#### 필수 필드
```json
{
  "decisions": [
    {
      "symbol": "BTC",           // 필수
      "action": "buy",           // 필수: buy, sell, hold
      "percentage": 5.0,         // 필수: 0.0 ~ 100.0
      "reason": "MA120 돌파",    // 필수: 구체적 근거
      "urgency": "high"          // 필수: normal, high
    }
  ],
  "rationale": "전체 판단 근거"  // 필수
}
```

#### 템플릿 검증 로직
```python
# ai_strategy/process2.py
def validate_template(response):
    required_fields = ["decisions", "rationale"]
    for field in required_fields:
        if field not in response:
            raise ValueError(f"Missing field: {field}")

    for decision in response["decisions"]:
        required = ["symbol", "action", "percentage", "reason", "urgency"]
        for field in required:
            if field not in decision:
                raise ValueError(f"Missing field: {field}")
```

### 3.2 HOLD 우선 원칙

**확신이 없으면 HOLD가 정답입니다.**

```python
# 신호 불분명 시
if g_sector_signals.mixed() and c_sector_signals.mixed():
    action = "HOLD"
    reason = "G섹터/C섹터 신호 혼재. 명확한 방향성 대기"

# CIO 목표와 신호 불일치 시
if cio_target > current_weight and g_sector_signals.negative():
    action = "HOLD"
    reason = "CIO 목표 증가지만 G섹터 신호 부정적. 타이밍 대기"
```

### 3.3 AI 자동편입 존중 원칙

**AI 자동편입(VERIFIED) 코인은 신중히 매도합니다.**

```python
# AI 자동편입 코인 매도 조건
if verification_tier == "VERIFIED":
    # 강력한 매도 신호 필요
    if ma120_broken and macd_dead_cross and rsi < 30:
        action = "SELL"
        reason = "VERIFIED 코인이지만 MA120 이탈 + MACD 데드크로스 + RSI 과매도"
    else:
        action = "HOLD"
        reason = "VERIFIED 코인. 단기 조정은 보유"
```

### 3.4 포지션 크기 자동 조정

**percentage는 현재 포지션 고려하여 자동 조정됩니다.**

```python
# BUY 시
if action == "buy":
    # CIO 목표까지 남은 비중
    remaining = cio_target - current_weight
    # 한 번에 최대 5% 매수
    percentage = min(remaining, 5.0)

# SELL 시
if action == "sell":
    # 현재 보유 비중
    holdings = current_weight
    # 한 번에 최대 5% 매도
    percentage = min(holdings, 5.0)
```

---

### 3.5 재평가 상태 코인 처리 원칙 ⭐

> **[신규 추가 2025-10-25]**: 트레일링 스탑 익절 후 재진입 판단
>
> CIO비중_명세서 Section 3.4 참조: [재평가 상태 관리 원칙](CIO비중_명세서.md#34-재평가-상태-관리-원칙--추세-추적-시스템)

#### 3.5.1 "재평가" 상태의 의미

**Process2 관점에서 "재평가" 코인**:
- ✅ **전량 익절 완료**: 트레일링 스탑으로 수익 실현
- ✅ **보유수량 0**: 현재 미보유 상태
- ✅ **CIO 감시 중**: CIO가 추세 재진입 기회 평가 중
- ✅ **재매수 가능**: CIO가 '활성'으로 전환 시 재매수

#### 3.5.2 트레일링 스탑 → '재평가' 전환 로직

**트레일링 스탑 전량 익절 시 "재평가" 상태로 전환**:

**코드 위치**: `trade_manager.py` Lines 914-925 (execute_sell 함수)

```python
# 트레일링 스탑에 의한 전량익절인 경우 '재평가' 상태로 전환
is_trailing_stop_profit = (
    decision_type in ['전량익절', '전량익절(전량 전환)'] and
    final_reason and '트레일링' in final_reason and
    profit_amount > 0
)

if is_trailing_stop_profit:
    logger.info(f"🔄 [{symbol}] 트레일링 스탑 익절 완료. 관리상태를 '재평가'로 변경합니다.")
    db_manager.update_holding_status(symbol, {'관리상태': '재평가'})
else:
    logger.info(f"📤 [{symbol}] 시스템 규칙 매도 완료. 관리상태를 '제외'로 변경합니다.")
    db_manager.update_holding_status(symbol, {'관리상태': '제외'})
```

**트리거 흐름**:
1. `main.py` Line 192: `check_profit_loss_triggers()` 호출
2. 트레일링 스탑 조건 충족 → `reason="동적 트레일링 스탑(8.0%) 발동..."`
3. `main.py` Line 203: `execute_sell(reason=...)` 호출
4. `trade_manager.py`: `'트레일링' in final_reason` → '재평가' 전환

#### 3.5.3 CIO의 역할 (재진입 판단)

**CIO는 정기 평가 시 "재평가" 코인을 분석**:

1. **상승 시그널 포착** → '활성' 전환 + 목표 비중 설정
   ```
   CIO 판단: "MA120 위 유지 + MACD 상승. 추세 지속"
   → management_status: '재평가' → '활성'
   → GPT보유비중: 0% → 5%
   → Process2: 5% 매수 실행
   ```

2. **하락 시그널 포착** → '제외' 전환
   ```
   CIO 판단: "MA120 이탈 + MACD 하락. 추세 종료"
   → management_status: '재평가' → '제외'
   → GPT보유비중: 0% 유지
   → Process2: 더 이상 분석 대상 아님
   ```

3. **신호 불분명** → '재평가' 유지
   ```
   CIO 판단: "추세 불분명. 관찰 지속"
   → management_status: '재평가' 유지
   → GPT보유비중: 0% 유지
   → Process2: HOLD (아무 행동 안 함)
   ```

#### 3.5.4 Process2 매매 판단 시 고려사항

**"재평가" 코인 매수 신호 (CIO가 '활성' 전환 시)**:

```python
# CIO가 '재평가' → '활성' 전환 + 목표 비중 5% 설정
if management_status == '활성' and cio_target == 5.0 and current_weight == 0:
    # 전량 익절 후 재진입 시나리오

    # G섹터 신호 확인
    if ma120_above and macd_bullish and rsi_ok:
        action = "BUY"
        percentage = 5.0
        reason = "CIO 재진입 판단. 전량 익절 후 추세 재확인. G섹터 신호 긍정적"
        urgency = "normal"
    else:
        # CIO는 재진입 판단했지만 G섹터 신호 부정적
        action = "HOLD"
        reason = "CIO 재진입 판단하지만 G섹터 신호 부정적. 타이밍 대기"
        urgency = "normal"
```

**⚠️ 중요**: Process2는 CIO 목표를 **참고**하되, G섹터/C섹터 신호를 우선 고려합니다.

#### 3.5.5 시나리오 예시

**시나리오: SOPH 트레일링 스탑 익절 후 재진입**

```
Day 1 (10:00): SOPH 트레일링 스탑 익절
  ├─ Process2 실행: 전량 매도 (100%)
  ├─ holding_status.관리상태 = '재평가'
  ├─ holding_status.보유수량 = 0
  └─ holding_status.GPT보유비중 = 0%

Day 2 (09:00): CIO 정기 평가
  ├─ SOPH 분석: "익절 후 재상승 (+10%)"
  ├─ MA120 위 유지, MACD 상승 전환
  ├─ CIO 판단: "추세 지속, 재진입"
  ├─ management_status: '재평가' → '활성'
  └─ GPT보유비중: 0% → 5%

Day 2 (10:00): Process2 실행
  ├─ CIO 목표: 5% (현재 0%)
  ├─ G섹터 신호: 긍정적 (MA120 위, MACD 상승)
  ├─ 판단: BUY
  ├─ percentage: 5.0
  ├─ reason: "CIO 재진입 판단. 익절 후 추세 재확인. G섹터 긍정적"
  └─ 5% 매수 실행 ✅
```

---

### 3.6 트레일링 스탑 시스템 ⭐

> **[신규 추가 2025-10-25]**: ATR 기반 동적 트레일링 스탑 규칙
>
> **위치**: `trade_manager.py` (Lines 370-449) + `config.py` (DYNAMIC_THRESHOLD_CONFIG)

#### 3.6.1 트레일링 스탑의 역할

**트레일링 스탑은 수익 보호 최후의 보루입니다.**

```
Process2 AI 판단 (창)
  └─ 임무: 추세의 끝을 탐색하며 수익 극대화

시스템 트레일링 스탑 (방패)
  └─ 임무: 수익을 기계적으로 보호
```

**핵심 철학: "시스템은 방패, AI는 창"**
- AI(Process2)는 추세를 최대한 따라가며 수익 극대화
- 시스템은 예측 가능한 기계적 규칙으로 수익 보호
- AI 판단보다 시스템 규칙이 우선

#### 3.6.2 ATR 기반 동적 계산 방식

**config.py 설정값**:
```python
DYNAMIC_THRESHOLD_CONFIG = {
    'trailing_stop_activation': 12.0,      # 활성화 기준: 12% 수익
    'use_atr_trailing_stop': True,         # ATR 동적 계산 활성화
    'atr_multiplier': 3.0,                 # ATR 멀티플라이어
    'trailing_stop_distance': 8.0,         # 최대 거리 (ATR 미사용 시 기본값)
}
```

**동적 거리 계산 로직**:
```python
# trade_manager.py (Lines 383-406)
atr_percent = (atr_value / current_price) * 100
dynamic_distance = atr_percent × 3.0

# 범위 제한: 최소 2% ~ 최대 8%
trailing_distance = max(2.0, min(8.0, dynamic_distance))
```

**변동성에 따른 자동 조절**:
| ATR (변동성) | 계산값 | 실제 적용 | 효과 |
|------------|--------|---------|------|
| 0.5% | 0.5% × 3.0 = 1.5% | **2.0%** (최소값 적용) | 사소한 조정에도 익절 |
| 2.0% | 2.0% × 3.0 = 6.0% | **6.0%** | 적절한 여유 |
| 3.5% | 3.5% × 3.0 = 10.5% | **8.0%** (최대값 적용) | 과도한 여유 방지 |

#### 3.6.3 트레일링 스탑 발동 조건

**1단계: 활성화 조건**
```python
if highest_profit >= 12.0:  # 최고 수익률 12% 이상
    trailing_stop_activated = True
```

**2단계: 발동 조건**
```python
# 동적 거리 계산
trailing_distance = calculate_dynamic_distance(symbol)  # 2.0% ~ 8.0%

# 발동 체크
if current_profit < (highest_profit - trailing_distance):
    execute_full_profit_taking()  # 전량익절 실행
```

**예시: BTC 트레일링 스탑**
```
상황: BTC 진입가 100,000원
      ATR: 2,000원 (2.0%)

Step 1: 수익률 15% 도달 (115,000원)
  → highest_profit = 15.0%
  → trailing_stop_activated = True ✅

Step 2: 동적 거리 계산
  → ATR% = 2.0%
  → dynamic_distance = 2.0% × 3.0 = 6.0%
  → trailing_price = 115,000 × (1 - 0.06) = 108,100원

Step 3: 가격 하락
  → 현재가 109,000원: 수익률 9.0% (아직 안전) ✅
  → 현재가 108,000원: 수익률 8.0% < (15.0% - 6.0%) → 전량익절! 🔥
```

#### 3.6.4 트레일링 스탑 후 재평가 전환

**trade_manager.py (Lines 914-925)**:
```python
# 트레일링 스탑에 의한 전량익절인 경우 '재평가' 상태로 전환
is_trailing_stop_profit = (
    decision_type in ['전량익절', '전량익절(전량 전환)'] and
    final_reason and '트레일링' in final_reason and
    profit_amount > 0
)

if is_trailing_stop_profit:
    logger.info(f"🔄 [{symbol}] 트레일링 스탑 익절 완료. 관리상태를 '재평가'로 변경합니다.")
    db_manager.update_holding_status(symbol, {'관리상태': '재평가'})
else:
    logger.info(f"📤 [{symbol}] 시스템 규칙 매도 완료. 관리상태를 '제외'로 변경합니다.")
    db_manager.update_holding_status(symbol, {'관리상태': '제외'})
```

**흐름도**:
```
트레일링 스탑 발동 (수익률 하락)
  ├─ trade_manager.py: 전량익절 실행
  ├─ 수익 확정: +8% ~ +15% (동적 거리에 따라)
  ├─ 관리상태: '활성' → '재평가'
  └─ 추세 재진입 감시 시작
      ↓
CIO 다음 평가 (4시간 후)
  ├─ '재평가' 코인 분석
  ├─ 상승 시그널? → '활성' 전환 + 목표 비중 설정
  └─ 하락 시그널? → '제외' 전환
      ↓
Process2 매매 판단 (1시간 후)
  └─ CIO 목표 + G섹터 신호 종합하여 재진입 결정
```

#### 3.6.5 AI 프롬프트 전달 (정확한 동적 계산 정보)

**prompts.py (Lines 58-73)**:
```python
# config.py에서 동적 설정값 추출
activation_threshold = 12.0
atr_multiplier = 3.0
min_distance = 2.0
max_distance = 8.0

# AI 프롬프트에 정확한 정보 전달
formatted_rules = COMMON_AI_RULES.format(
    activation_threshold=activation_threshold,
    atr_multiplier=atr_multiplier,
    min_distance=min_distance,
    max_distance=max_distance
)
```

**AI가 받는 프롬프트 (cio_base_rules.txt Lines 220-227)**:
```
- **시스템의 역할**: 우리 시스템에는 강력하고 예측 가능한 **ATR 기반 동적 트레일링 스탑**이 내장되어 있습니다.
  * **활성화 조건**: `highest_profit`가 **12.0%**를 초과하면 자동 활성화
  * **동적 거리 계산**: 현재가 기준 ATR 값을 계산하여 **`ATR% × 3.0`**로 트레일링 거리를 동적으로 산출
  * **범위 제한**: 최소 **2.0%** ~ 최대 **8.0%** 사이로 자동 조절 (변동성에 따라 적응)
  * **발동 조건**: 현재 수익률이 `highest_profit - 동적거리` 지점 아래로 하락 시 자동 '전량익절' 실행
  * **핵심 특징**: 고정된 거리가 아닌 **시장 변동성(ATR)에 따라 유연하게 조절**되어 사소한 조정에는 이탈하지 않고, 진짜 추세 전환 시 빠르게 보호합니다.
```

#### 3.6.6 Process2가 알아야 할 핵심

**트레일링 스탑은 AI 판단을 덮어씁니다**:
```python
# ❌ Process2가 "HOLD" 판단해도
if trailing_stop_triggered:
    system_executes_full_sell()  # 시스템이 강제 전량익절

# ✅ Process2는 시스템을 신뢰하고 추세 따라가기
action = "HOLD"
reason = "추세 지속 중. 시스템 트레일링 스탑이 수익 보호할 것"
```

**Process2 의사결정 시 고려사항**:
1. ✅ **추세 추종 우선**: 트레일링 스탑이 보호하므로 추세를 끝까지 따라감
2. ✅ **변동성 인지**: ATR 기반 동적 거리로 사소한 조정에 이탈하지 않음
3. ✅ **재진입 준비**: 트레일링 스탑 후 '재평가' 전환되어 재진입 기회 포착
4. ❌ **조기 익절 금지**: "수익률 12% 달성했으니 익절"은 시스템 철학 위배

---

#### 3.6.7 실시간 동작 흐름 (5분 주기) ⭐⭐⭐

> **핵심**: 트레일링 스탑은 매 5분마다 자동으로 체크되며, AI 판단 없이 즉시 실행됩니다.

**전체 흐름도**:

```
┌─────────────────────────────────────────────────────────────┐
│  매 5분마다 Process1 실행 (main.py)                         │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│  Step 1: Upbit 실시간 보유 현황 동기화                       │
│  📍 trade_manager.py::update_all_holdings_from_upbit()      │
│                                                             │
│  ✅ 각 코인마다:                                            │
│    1. 현재가 조회 (pyupbit API)                             │
│    2. 수익률 계산                                           │
│    3. highest_profit 자동 업데이트 (Lines 161-162) ⭐       │
│       → max(기존_highest, 현재_수익률)                      │
│       → DB holding_status 테이블에 자동 저장!               │
│       → 시스템 재시작해도 유지됨                            │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│  Step 2: 트레일링 스탑 체크                                  │
│  📍 trade_manager.py::check_profit_loss_triggers()          │
│                                                             │
│  ✅ 매 5분마다 모든 보유 코인 실시간 체크:                   │
│                                                             │
│  1️⃣ DB에서 highest_profit 읽기 (Line 346)                  │
│     holding.get('highest_profit', profit_rate)              │
│                                                             │
│  2️⃣ 트레일링 스탑 활성화 조건 체크 (Lines 371-375)          │
│     - highest_profit >= 12%                                 │
│     - profit_rate > 0 (현재도 수익 상태)                    │
│     → 조건 충족 시 활성화 ✅                                 │
│                                                             │
│  3️⃣ ATR 동적 거리 계산 (Lines 387-406) ⭐                  │
│     - get_technical_indicators(symbol) 호출                 │
│     - ATR 값 실시간 조회 (업비트 API)                        │
│     - atr_percent = (ATR / current_price) × 100             │
│     - dynamic_distance = atr_percent × 3.0                  │
│     - trailing_distance = max(2.0, min(8.0, dynamic))      │
│     → 매 5분마다 재계산! (변동성 실시간 반영)                │
│                                                             │
│  4️⃣ 발동 조건 체크 (Lines 409-433)                          │
│     trailing_stop_line = highest_profit - trailing_distance│
│     if profit_rate <= trailing_stop_line:                  │
│         trigger = {'type': '전량익절', ...}                │
│         → 전량익절 트리거 생성! 🔥                           │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│  Step 3: 즉시 매도 실행 (AI 판단 불필요!)                   │
│  📍 main.py::_execute_trades_and_triggers()                 │
│                                                             │
│  ✅ 트레일링 스탑 트리거 즉시 처리 (Lines 196-203):         │
│     - trigger['type'] == '전량익절' 감지                    │
│     - execute_sell() 즉시 호출                              │
│     - AI 분석 없이 시스템이 바로 실행!                       │
│     - TWAP 3분할 매도 실행                                   │
│     - 관리상태: '활성' → '재평가' 전환                       │
└─────────────────────────────────────────────────────────────┘
```

**실제 동작 예시 (BTC 트레일링 스탑)**:

```
09:00 - Process1 실행
  ├─ update_all_holdings_from_upbit()
  │   ├─ BTC 현재가: 115,000원
  │   ├─ 진입가: 100,000원
  │   ├─ 수익률: +15.0%
  │   └─ highest_profit: 15.0% (DB 저장) ⭐
  │
  └─ check_profit_loss_triggers()
      ├─ highest_profit: 15.0% ≥ 12.0% → 활성화 ✅
      ├─ get_technical_indicators('BTC')
      │   └─ ATR: 2,000원 (2.0%)
      ├─ dynamic_distance = 2.0% × 3.0 = 6.0%
      ├─ trailing_stop_line = 15.0% - 6.0% = 9.0%
      ├─ 현재 수익률 15.0% > 9.0% → 안전 ✅
      └─ 트리거 없음

09:05 - Process1 실행
  ├─ update_all_holdings_from_upbit()
  │   ├─ BTC 현재가: 118,000원
  │   ├─ 수익률: +18.0%
  │   └─ highest_profit: 18.0% (업데이트) ⬆️
  │
  └─ check_profit_loss_triggers()
      ├─ highest_profit: 18.0% (최고점 갱신!)
      ├─ dynamic_distance = 6.0%
      ├─ trailing_stop_line = 18.0% - 6.0% = 12.0%
      └─ 현재 수익률 18.0% > 12.0% → 안전 ✅

09:10 - Process1 실행 (트레일링 스탑 발동!)
  ├─ update_all_holdings_from_upbit()
  │   ├─ BTC 현재가: 112,000원
  │   ├─ 수익률: +12.0%
  │   └─ highest_profit: 18.0% (유지) ✅
  │       → 과거 최고점을 DB가 기억!
  │
  └─ check_profit_loss_triggers()
      ├─ highest_profit: 18.0% (DB에서 읽음)
      ├─ ATR 재계산: 2,000원 (2.0%)
      ├─ dynamic_distance = 2.0% × 3.0 = 6.0%
      ├─ trailing_stop_line = 18.0% - 6.0% = 12.0%
      ├─ 현재 수익률 12.0% ≤ 12.0% → 발동! 🔥
      │
      └─ 트리거 생성:
          {
            'symbol': 'BTC',
            'type': '전량익절',
            'reason': '동적 트레일링 스탑(6.00%) 발동',
            'confidence': 100
          }

09:10 - 즉시 매도 실행 (AI 판단 없음!)
  ├─ execute_sell(symbol='BTC', decision_type='전량익절', ...)
  │   ├─ TWAP 3분할 매도 (1차 40% → 2차 30% → 3차 30%)
  │   ├─ 평균 체결가: 112,000원
  │   ├─ 최종 수익: +12.0%
  │   ├─ 수익금: 120,000원
  │   └─ 관리상태: '활성' → '재평가' ✅
  │
  └─ DB 업데이트:
      ├─ 보유수량: 0
      ├─ highest_profit: 0 (초기화)
      ├─ 관리상태: '재평가'
      └─ 거래 기록 저장 (trade_history 테이블)
```

**핵심 포인트**:

1. **highest_profit는 DB가 관리**:
   ```python
   # trade_manager.py Lines 161-162
   db_highest_profit = db_holding.get('highest_profit', 0)
   update_data['highest_profit'] = max(db_highest_profit, profit_rate)

   # ✅ 매 5분마다 자동 업데이트
   # ✅ 절대 하락하지 않음 (max 함수)
   # ✅ 시스템 재시작해도 유지 (DB 저장)
   ```

2. **ATR은 매 5분마다 재계산**:
   ```python
   # trade_manager.py Lines 389-399
   indicators = get_technical_indicators(symbol)  # 실시간 조회
   atr_value = indicators.get('atr', 0)
   dynamic_distance = (atr_value / current_price) × 100 × 3.0

   # ✅ 변동성 실시간 반영
   # ✅ 고정값 아님!
   ```

3. **즉시 실행 메커니즘**:
   ```python
   # main.py Lines 196-203
   if trigger['type'] in ['전량익절', '시스템청산']:
       execute_sell()  # AI 분석 없이 즉시 실행!

   # ✅ Process2 AI 판단 불필요
   # ✅ 최대 5분 지연 (다음 Process1 실행까지)
   # ✅ 시스템 규칙이 AI보다 우선
   ```

**DB 테이블 구조 (holding_status)**:

```sql
{
  '코인이름': 'BTC',
  '수익률': 12.0,           -- 현재 수익률 (매 5분 업데이트)
  'highest_profit': 18.0,   -- 최고 수익률 기록 ⭐
  '관리상태': '활성',       -- 활성/재평가/제외
  '보유수량': 0.5,
  '평가금액': 5600000,
  -- ... 기타 필드
}
```

**Q&A**:

| 질문 | 답변 |
|------|------|
| **5분마다 확인하나요?** | ✅ 맞습니다. Process1이 5분 주기로 실행됨 |
| **highest_profit은 언제 업데이트?** | ✅ 매 5분마다 자동 업데이트 (Line 162) |
| **멀티플라이어도 5분마다 계산?** | ✅ 맞습니다. ATR 실시간 조회 + 계산 (Lines 389-399) |
| **실시간 대응 가능?** | ✅ 가능! 최대 5분 지연만 발생 |
| **시스템 재시작 시 highest_profit 유지?** | ✅ DB에 저장되므로 유지됨 |
| **AI가 판단하나요?** | ❌ 아니요. 시스템이 즉시 실행 (AI 불필요) |

---

## 4. 시나리오 라이브러리

### 시나리오 1: CIO 목표 증가 + G섹터 긍정적

**상황**:
- 코인: BTC
- CIO 목표: 15% (이전 10%)
- 현재 비중: 10%
- G섹터: MA120 위 +3%, MACD 일봉 상승, MACD 1시간 상승, RSI 55
- C섹터: MA60 위, 거래량 증가
- Fear & Greed: 60

**올바른 판단**:
```json
{
  "decisions": [
    {
      "symbol": "BTC",
      "action": "buy",
      "percentage": 5.0,
      "reason": "CIO 목표 15%로 증가. G섹터 신호 모두 긍정적 (MA120 위, MACD 상승, RSI 55). 점진적 매수 시작",
      "urgency": "normal"
    }
  ],
  "rationale": "CIO 방향성과 G섹터 신호 일치. 5% 매수로 목표 비중 접근"
}
```

**잘못된 판단**:
```json
❌ "action": "hold"
→ 이유: CIO 방향성 + G섹터 신호 모두 긍정적인데 HOLD는 기회 상실
```

---

### 시나리오 2: CIO 목표 증가 + G섹터 부정적

**상황**:
- 코인: ETH
- CIO 목표: 12% (이전 8%)
- 현재 비중: 8%
- G섹터: MA120 아래 -2%, MACD 일봉 하락, RSI 35
- C섹터: MA60 아래, 거래량 감소
- Fear & Greed: 25

**올바른 판단**:
```json
{
  "decisions": [
    {
      "symbol": "ETH",
      "action": "hold",
      "percentage": 0.0,
      "reason": "CIO 목표 증가지만 G섹터 신호 모두 부정적 (MA120 아래, MACD 하락, 공포 국면). 타이밍 대기",
      "urgency": "normal"
    }
  ],
  "rationale": "CIO 방향성 무시. 기술적 신호 우선. 반등 신호 확인 후 매수"
}
```

**잘못된 판단**:
```json
❌ "action": "buy", "reason": "CIO 목표 증가로 매수"
→ 이유: G섹터 신호 무시한 기계적 매수. 하락 추세 진입 리스크
```

---

### 시나리오 3: CIO 목표 감소 + 단기 반등 신호

**상황**:
- 코인: SOL
- CIO 목표: 5% (이전 10%)
- 현재 비중: 10%
- G섹터: MA120 위, MACD 1시간 골든크로스 (방금 발생), RSI 45
- C섹터: MA60 위, 거래량 급증
- Fear & Greed: 55
- 특이사항: 30분 전 급락 후 반등 시작

**올바른 판단**:
```json
{
  "decisions": [
    {
      "symbol": "SOL",
      "action": "hold",
      "percentage": 0.0,
      "reason": "CIO 목표 감소지만 단기 급락 후 반등 신호 (MACD 골든크로스, 거래량 급증). 반등 확인 후 매도 판단",
      "urgency": "normal"
    }
  ],
  "rationale": "CIO 방향성 무시. 단기 반등 가능성. 추가 확인 필요"
}
```

**잘못된 판단**:
```json
❌ "action": "sell", "reason": "CIO 목표 감소로 매도"
→ 이유: 반등 신호 무시한 기계적 매도. 저점 매도 리스크
```

---

### 시나리오 4: CIO 목표 유지 + 긴급 매수 신호

**상황**:
- 코인: MATIC
- CIO 목표: 8% (유지)
- 현재 비중: 8%
- G섹터: MA120 돌파 (방금 발생), MACD 일봉 골든크로스, RSI 65
- C섹터: MA60 위, 거래량 급증 300%
- Fear & Greed: 70
- 특이사항: 주요 저항선 돌파

**올바른 판단**:
```json
{
  "decisions": [
    {
      "symbol": "MATIC",
      "action": "buy",
      "percentage": 3.0,
      "reason": "CIO 목표 유지지만 긴급 매수 신호 (MA120 돌파, MACD 골든크로스, 거래량 급증 300%, 주요 저항선 돌파). 추세 전환 포착",
      "urgency": "high"
    }
  ],
  "rationale": "CIO 목표 무시. 긴급 매수 신호 우선. 추세 전환 초기 진입"
}
```

**잘못된 판단**:
```json
❌ "action": "hold", "reason": "CIO 목표 유지로 HOLD"
→ 이유: 긴급 신호 무시. 추세 전환 초기 진입 기회 상실
```

---

### 시나리오 5: 과매수 방지

**상황**:
- 코인: AVAX
- CIO 목표: 10%
- 현재 비중: 6%
- 최근 매수 이력: 30분 전 3% 매수, 50분 전 2% 매수
- G섹터: 여전히 긍정적
- C섹터: 여전히 긍정적

**올바른 판단**:
```json
{
  "decisions": [
    {
      "symbol": "AVAX",
      "action": "hold",
      "percentage": 0.0,
      "reason": "G섹터 신호 긍정적이지만 1시간 내 2회 매수 완료 (3% + 2%). 과매수 방지",
      "urgency": "normal"
    }
  ],
  "rationale": "무분별한 매매 억제. 이전 매수 효과 관찰 필요"
}
```

**잘못된 판단**:
```json
❌ "action": "buy", "reason": "CIO 목표까지 4% 남음. 매수"
→ 이유: 과매수 방지 규칙 위배. 무분별한 매매
```

---

### 시나리오 6: 미세 조정 방지

**상황**:
- 코인: LINK
- CIO 목표: 7.5%
- 현재 비중: 7.2%
- 비중 차이: 0.3%
- G섹터: 중립
- C섹터: 중립

**올바른 판단**:
```json
{
  "decisions": [
    {
      "symbol": "LINK",
      "action": "hold",
      "percentage": 0.0,
      "reason": "CIO 목표와 비중 차이 0.3% (1% 미만). 미세 조정 불필요. 수수료 고려",
      "urgency": "normal"
    }
  ],
  "rationale": "미세 조정은 수수료만 낭비. HOLD 유지"
}
```

**잘못된 판단**:
```json
❌ "action": "buy", "percentage": 0.3, "reason": "CIO 목표 달성"
→ 이유: 0.3% 매수는 수수료 대비 비효율
```

---

### 시나리오 7: AI 자동편입(VERIFIED) 매도 신중

**상황**:
- 코인: ARB
- CIO 목표: 3% (이전 8%)
- 현재 비중: 8%
- Verification Tier: VERIFIED (AI 자동편입)
- G섹터: MA120 위, MACD 1시간 하락 (일봉은 상승), RSI 48
- C섹터: MA60 위, 거래량 감소
- 특이사항: 단기 조정 중

**올바른 판단**:
```json
{
  "decisions": [
    {
      "symbol": "ARB",
      "action": "hold",
      "percentage": 0.0,
      "reason": "CIO 목표 감소지만 VERIFIED 코인. MA120 위 유지, 일봉 MACD 상승. 단기 조정으로 판단. 보유",
      "urgency": "normal"
    }
  ],
  "rationale": "AI 자동편입 존중. 중장기 추세 유지. 단기 조정은 보유"
}
```

**잘못된 판단**:
```json
❌ "action": "sell", "reason": "CIO 목표 감소로 매도"
→ 이유: VERIFIED 코인 성급한 매도. 단기 조정 무시
```

---

### 시나리오 8: AI 자동편입(VERIFIED) 강력한 매도 신호

**상황**:
- 코인: FTM
- CIO 목표: 2% (이전 10%)
- 현재 비중: 10%
- Verification Tier: VERIFIED
- G섹터: MA120 이탈 (방금 발생), MACD 일봉 데드크로스, RSI 28
- C섹터: MA60 이탈, 거래량 급감
- Fear & Greed: 20

**올바른 판단**:
```json
{
  "decisions": [
    {
      "symbol": "FTM",
      "action": "sell",
      "percentage": 5.0,
      "reason": "VERIFIED 코인이지만 강력한 매도 신호 (MA120 이탈, MACD 데드크로스, RSI 28, 공포 국면). 추세 전환 판단. 점진적 매도",
      "urgency": "high"
    }
  ],
  "rationale": "AI 자동편입 존중하지만 명확한 추세 전환. 손절 우선"
}
```

**잘못된 판단**:
```json
❌ "action": "hold", "reason": "VERIFIED 코인이므로 보유"
→ 이유: 강력한 매도 신호 무시. 손실 확대 리스크
```

---

### 시나리오 9: 긴급 매도 신호

**상황**:
- 코인: ATOM
- CIO 목표: 6% (유지)
- 현재 비중: 6%
- G섹터: MA120 이탈 (5분 전), MACD 일봉 데드크로스, RSI 32
- C섹터: MA60 이탈, 거래량 급감
- Fear & Greed: 15 (극단적 공포)
- 특이사항: 주요 지지선 붕괴

**올바른 판단**:
```json
{
  "decisions": [
    {
      "symbol": "ATOM",
      "action": "sell",
      "percentage": 5.0,
      "reason": "CIO 목표 유지지만 긴급 매도 신호 (MA120 이탈, 주요 지지선 붕괴, 극단적 공포 국면). 추가 하락 방지",
      "urgency": "high"
    }
  ],
  "rationale": "CIO 목표 무시. 긴급 매도 신호 우선. 손절 후 재진입 전략"
}
```

**잘못된 판단**:
```json
❌ "action": "hold", "reason": "CIO 목표 유지로 HOLD"
→ 이유: 긴급 신호 무시. 추가 손실 리스크
```

---

### 시나리오 10: 신호 혼재 (HOLD 우선)

**상황**:
- 코인: NEAR
- CIO 목표: 5%
- 현재 비중: 5%
- G섹터: MA120 위 +1%, MACD 일봉 상승, MACD 1시간 하락, RSI 52
- C섹터: MA60 위, 거래량 보통
- Fear & Greed: 50

**올바른 판단**:
```json
{
  "decisions": [
    {
      "symbol": "NEAR",
      "action": "hold",
      "percentage": 0.0,
      "reason": "G섹터 신호 혼재 (일봉 상승 vs 1시간 하락). C섹터 중립. 명확한 방향성 대기",
      "urgency": "normal"
    }
  ],
  "rationale": "신호 불분명 시 HOLD 우선. 명확한 신호 대기"
}
```

**잘못된 판단**:
```json
❌ "action": "buy", "reason": "MACD 일봉 상승으로 매수"
→ 이유: 1시간 하락 신호 무시. 불분명한 타이밍 매수
```

---

## 5. 금지 사항

### 5.1 절대 금지

#### ❌ CIO 목표를 강제 명령으로 간주
```python
# 잘못된 예시
if cio_target > current_weight:
    action = "buy"  # G섹터 신호 무시 ❌
```

#### ❌ 템플릿 미준수
```python
# 잘못된 예시
response = "BTC를 5% 매수하겠습니다"  # JSON 템플릿 아님 ❌
response = {"symbol": "BTC", "action": "buy"}  # 필수 필드 누락 ❌
```

#### ❌ 과매매 (1시간 내 3회 이상 매매)
```python
# 잘못된 예시
# 10분 전 매수, 30분 전 매수, 50분 전 매수
# → 또 매수 시도 ❌
```

#### ❌ 신호 혼재 시 무리한 매매
```python
# 잘못된 예시
if macd_1h_up and macd_1d_down:
    action = "buy"  # 일봉 하락 신호 무시 ❌
```

### 5.2 철학 위배 사례

#### ❌ "CIO 절대 복종"
```
잘못된 프롬프트 예시:
"CIO 목표 비중을 무조건 따른다"
"CIO가 증가 지시하면 즉시 매수"

→ 이유: Process2의 자율 판단 박탈. G섹터 신호 무시
```

#### ❌ "기계적 매매"
```
잘못된 프롬프트 예시:
"RSI 50 이상이면 매수, 50 미만이면 매도"
"MACD 골든크로스면 즉시 매수"

→ 이유: 맥락 무시한 기계적 판단
```

#### ❌ "템플릿 자유 형식"
```
잘못된 프롬프트 예시:
"자유롭게 판단 근거를 작성하세요"

→ 이유: JSON 템플릿 강제 없음. 시스템 크래시 위험
```

### 5.3 허용되는 예외

#### ✅ 긴급 신호 시 CIO 무시
```python
# 허용됨
if urgent_buy_signal:
    action = "buy"
    reason = "CIO 목표 무시. 긴급 매수 신호 우선"
```

#### ✅ HOLD 우선 원칙
```python
# 허용됨
if signals_mixed:
    action = "hold"
    reason = "신호 혼재. 명확한 방향성 대기"
```

---

## 6. 검증 체크리스트

### 6.1 프롬프트 수정 후 필수 확인

#### ✅ Test 1: 템플릿 준수 확인
```
5회 반복 테스트:
- JSON 템플릿 정확히 출력 (100%)
- 필수 필드 모두 포함 (100%)
```

#### ✅ Test 2: CIO 참고 (강제 아님) 확인
```
CIO 목표 증가 + G섹터 부정적:
- HOLD 판단 (CIO 무시)
- 5회 중 5회 일관성 확인
```

#### ✅ Test 3: 과매매 방지 확인
```
1시간 내 2회 매수 완료:
- 추가 매수 시도 안 함 (100%)
```

#### ✅ Test 4: HOLD 우선 원칙 확인
```
신호 혼재:
- HOLD 판단 (무리한 매매 안 함)
- 5회 중 4회 이상 일관성 확인
```

#### ✅ Test 5: AI 자동편입 존중 확인
```
VERIFIED 코인 + 단기 조정:
- HOLD 판단 (성급한 매도 안 함)
- 5회 중 5회 일관성 확인
```

### 6.2 일관성 테스트 시나리오

**시나리오 A: CIO 증가 + G섹터 부정적**
```
5회 반복 테스트 결과:
1회: HOLD (CIO 무시) ✅
2회: HOLD (CIO 무시) ✅
3회: HOLD (CIO 무시) ✅
4회: HOLD (CIO 무시) ✅
5회: HOLD (CIO 무시) ✅

→ 일관성 100% 확인
```

**시나리오 B: 긴급 매수 신호**
```
5회 반복 테스트 결과:
1회: BUY (긴급 신호) ✅
2회: BUY (긴급 신호) ✅
3회: BUY (긴급 신호) ✅
4회: BUY (긴급 신호) ✅
5회: BUY (긴급 신호) ✅

→ 일관성 100% 확인
```

**시나리오 C: 신호 혼재**
```
5회 반복 테스트 결과:
1회: HOLD (신호 불분명) ✅
2회: HOLD (신호 불분명) ✅
3회: BUY (일봉 신호 우선) ⚠️ (AI 판단 차이)
4회: HOLD (신호 불분명) ✅
5회: HOLD (신호 불분명) ✅

→ 일관성 80% (허용 범위)
→ AI 자율 판단 작동 확인
```

### 6.3 철학 위배 여부 확인

#### ❌ 철학 위배 시그널
```
"CIO 목표 증가로 즉시 매수"
"MACD 골든크로스로 자동 매수"
"RSI 50 이상이므로 매수"

→ 즉시 프롬프트 수정 필요
```

#### ✅ 철학 부합 시그널
```
"CIO 목표 증가지만 G섹터 신호 부정적. HOLD"
"MACD 골든크로스지만 MA120 아래. 타이밍 대기"
"신호 혼재. 명확한 방향성 대기"

→ 데이터 종합 분석 + 맥락 고려 확인
```

---

## 7. 수정 이력

### 2025-10-25 (v1.2) - 페르소나 시스템 설명 추가

**변경 내용**: Process2 프롬프트 아키텍처 및 페르소나 시스템 상세 설명 추가

**배경**:
- 프롬프트 로그 분석 중 오해 발생: "로그만 보고 Process2는 Risk Guardian만 사용한다고 판단"
- 사용자 지적: "실제 로직에는 페르소나별로 구분되어있어. 코드를 확인해봐!"
- 핵심 문제: **프롬프트 로그 = 특정 순간의 스냅샷**, **실제 코드 = 전체 시스템 구조**

**추가된 내용**:

**① Section 0: 페르소나 시스템 이해** (신규 섹션):
- **0.1 프롬프트 로그 vs 실제 코드 차이**
  - 프롬프트 로그는 특정 시점의 선택된 페르소나만 표시
  - 실제 코드는 3가지 페르소나 동적 전환 시스템
  - 분석 시 주의사항: 로그만 보지 말고 코드 확인 필수

- **0.2 CIO와 Process2의 프롬프트 공유 구조**
  - Process2는 CIO 프롬프트 파일(cio_*.txt) 100% 공유
  - 별칭 시스템 (AGGRESSIVE_CHARTER = CIO_AGGRESSIVE)
  - CIO v1.3 개선사항 자동 반영 메커니즘

- **0.3 페르소나 선택 로직 (market_phase 기반)**
  - cache.py의 market_score 계산 시스템 (85점 만점)
  - Fear & Greed (30점) + BTC (35점) + ETH (20점)
  - 5단계 market_phase 결정 로직
  - prompts.py의 페르소나 선택 함수

- **0.4 페르소나별 특성 (CIO v1.3 반영)**
  - Risk Guardian / Balanced Analyst / Alpha Predator 비교표
  - 현금 비중, 개별 상한, 신규 편입 접근 차별화
  - CIO v1.3 개선사항 (질문 기반 평가, 변동성 연동 등)

- **0.5 System Prompt vs User Prompt 구조**
  - System Prompt: 페르소나 파일 + cio_base_rules.txt
  - User Prompt: CIO 브리핑 + 보유 현황 + 시장 데이터
  - CIO와 Process2의 차이점 (VERIFIED vs CIO 브리핑)

**② 버전 정보 업데이트**:
- 버전: v1.1 → v1.2
- 최종 업데이트: 2025-10-24 → 2025-10-25
- 실제 프롬프트 위치: 구체적 파일 경로 7개 명시

**효과**:
- ✅ **오해 방지**: 프롬프트 로그 분석 시 착각 방지
- ✅ **시스템 이해 개선**: 페르소나 동적 전환 메커니즘 명확화
- ✅ **프롬프트 공유 이해**: CIO와 Process2 아키텍처 설명
- ✅ **CIO v1.3 연계**: Process2에 자동 반영되는 개선사항 확인
- ✅ **문서 일관성**: CIO비중_명세서.md와 동일한 페르소나 설명

**관련 파일**:
- `docs/dev_guide/매매판단_명세서.md`: Section 0 추가 (Lines 16-161)
- `docs/dev_guide/트레이딩봇_수정이력.md`: Section 3.1 추가 (Process2 아키텍처 분석)

**관련 개선 작업**:
- CIO비중_명세서.md v1.3 (2025-10-25): 페르소나 차별화 및 철학 정렬
- 트레이딩봇_수정이력.md Section 3.1: Process2 프롬프트 아키텍처 검증

---

### 2025-10-24 (v1.1) - Fix 2: CIO-Process2 동기화 검증 로직 추가

**변경 내용**: Process2가 CIO 전략을 읽기 전에 DB 데이터 동기화를 검증하는 로직 추가

**배경**:
- Process2 큐 방식: CIO 실행 완료 → 큐에 매매판단 작업 추가 → Process2 워커가 큐에서 작업 가져와 실행
- 문제: CIO 실행 완료 시점과 DB 커밋 완료 시점 사이의 **시간차**(수백ms) 발생
- 결과: Process2가 CIO의 **이전 전략**을 읽어서 판단하는 경우 발생 (데이터 불일치)

**해결 방안**:

1. **동기화 검증 로직** (`main.py` Line 623-642):
   ```python
   # CIO 실행 시각을 큐에 함께 전달
   queue.put({
       'type': 'rebalance',
       'cio_timestamp': datetime.now(timezone.utc).isoformat()
   })

   # Process2 워커: 큐에서 작업 가져옴
   task = queue.get()
   cio_timestamp = task.get('cio_timestamp')

   # 2초 대기 (DB 커밋 완료 보장)
   time.sleep(2)

   # DB 검증: CIO 타임스탬프와 일치하는지 확인
   latest_cio = db_manager.get_latest_cio_report()
   if latest_cio['timestamp'] >= cio_timestamp:
       logger.info("✅ [CIO-Process2 동기화] DB 데이터 확인 완료")
       run_process2()
   else:
       logger.warning("⚠️ [CIO-Process2 동기화] DB 데이터 대기 중...")
   ```

2. **관련 코드 수정**:
   - `main.py`: Line 623-642 (동기화 검증 로직 추가)
   - `supabase_adapter.py`: `get_latest_cio_report()` 메서드 활용

3. **효과**:
   - ✅ 데이터 일관성 보장: Process2가 최신 CIO 전략을 확실히 읽음
   - ✅ 타임스탬프 기반 검증: 명확한 동기화 확인 메커니즘
   - ✅ 로그 투명성: 동기화 과정 디버깅 로그로 추적 가능
   - ✅ 큐 기반 아키텍처 유지: 백그라운드 워커 방식 그대로 활용

4. **검증 결과**:
   - 실행 로그: "✅ [CIO-Process2 동기화] DB 데이터 확인 완료"
   - 동작 확인: Process2가 CIO 최신 전략(AVNT 5% 목표)을 정확히 읽고 판단
   - 일관성 확인: 10회 연속 실행 시 모두 최신 데이터 읽음

5. **아키텍처 설계 원칙 준수**:
   - ✅ Top-Down 전략: CIO(전략) → Process2(전술) 계층 구조 유지
   - ✅ 데이터 신뢰성: DB 동기화 보장으로 시스템 일관성 향상
   - ✅ 디버깅 가능성: 로그를 통한 동기화 과정 추적

---

### 2025-10-25 (v1.4) - 재평가 시스템 구현 반영

**변경 내용**: Section 3.5.2 트레일링 스탑 → '재평가' 전환 로직 구현 내용 반영

**수정 내용**:
- **코드 위치 변경**: `process2.py` → `trade_manager.py` Lines 914-925
- **트리거 흐름 추가**: main.py → check_profit_loss_triggers → execute_sell 흐름 명시
- **조건 명확화**: `is_trailing_stop_profit` 조건 (decision_type + reason + profit_amount)

**배경**:
- 재평가 시스템 완전 구현 완료 (v1.5 CIO비중_명세서 참조)
- 실제 구현 위치와 명세서 일치화

---

### 2025-10-25 (v1.3) - 재평가 상태 코인 처리 원칙 추가

**변경 내용**: Section 3.5 "재평가 상태 코인 처리 원칙" 추가

**추가 내용**:
- 3.5.1: "재평가" 상태의 의미
- 3.5.2: Process2의 역할 (트레일링 스탑 익절)
- 3.5.3: CIO의 역할 (재진입 판단)
- 3.5.4: Process2 매매 판단 시 고려사항

**배경**: 트레일링 스탑 익절 후 추세 재진입 프로세스 설계

---

### 2025-10-24 (v1.0)

**변경 내용**: 최초 명세서 작성

**배경**:
- Process2 프롬프트의 일관성 문제 발견
- CIO 목표를 "강제 명령"으로 오해하는 경우 발생
- 템플릿 미준수로 시스템 크래시 발생
- 과매매로 인한 수수료 낭비 증가

**해결 방안**:
1. **핵심 철학 명확화**
   - CIO vs Process2 관계 재정의 (협력 관계, 상하 관계 아님)
   - CIO 목표는 "참고" (강제 아님)
   - 템플릿 기반 강제 출력 시스템 강조

2. **판단 원칙 우선순위 정립**
   - 1순위: G섹터/C섹터 신호 종합
   - 2순위: CIO 목표 비중 참고 (강제 아님)
   - 3순위: 과매매 방지
   - 4순위: 긴급도 판단

3. **특수 규칙 수립**
   - 템플릿 강제 출력 규칙
   - HOLD 우선 원칙
   - AI 자동편입 존중 원칙
   - 포지션 크기 자동 조정

4. **시나리오 라이브러리 구축**
   - 10개 시나리오로 구체적 판단 기준 제시
   - CIO 무시 가능한 경우 명시
   - HOLD 우선 원칙 강화

5. **검증 체크리스트 수립**
   - 5개 필수 테스트
   - 일관성 테스트 시나리오
   - 철학 위배 여부 확인

**기대 효과**:
- Process2의 자율 판단 능력 향상
- CIO와의 협력 관계 강화
- 템플릿 준수로 시스템 안정성 확보
- 과매매 방지로 수수료 절감

---

**📅 최종 업데이트**: 2025-10-24
**📦 작성자**: AI Trading Bot Team
